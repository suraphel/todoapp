{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"A:\\\\React\\\\Projects\\\\ReactCDN\\\\demoII\\\\todoapp\\\\todoapp\\\\src\\\\Container\\\\ContactUs.js\";\nimport React from 'react';\nimport Rainbow from '../hoc/Rainbow';\n\nconst ContactUs = props => {\n  //  setTimeout(()=> {\n  //      props.history.push('/home')\n  //  }, 2000);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"container\",\n    children: [/*#__PURE__*/_jsxDEV(\"h4\", {\n      className: \"center\",\n      children: \"ContactUs\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 11,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: \" Unfortunately, the world of programming doesn\\u2019t really fall into four cleanly separated parts. Therefore, the \\u201Cparts\\u201D of this book provide only a coarse classification of topics. We consider it a useful classification (obviously, or we wouldn\\u2019t have used it), but reality has a way of escaping neat classifications. For example, we need to use input operations far sooner than we can give a thorough explanation of C++ standard I/O streams (input/output streams). Where the set of topics needed to present an idea conflicts with the overall classification, we explain the minimum needed for a good presentation, rather than just referring to the complete explanation elsewhere. Rigid classifications work much better for manuals than for tutorials.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 12,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 10,\n    columnNumber: 9\n  }, this);\n};\n\n_c = ContactUs;\nexport default _c2 = Rainbow(ContactUs);\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"ContactUs\");\n$RefreshReg$(_c2, \"%default%\");","map":{"version":3,"sources":["A:/React/Projects/ReactCDN/demoII/todoapp/todoapp/src/Container/ContactUs.js"],"names":["React","Rainbow","ContactUs","props"],"mappings":";;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,OAAP,MAAoB,gBAApB;;AAGA,MAAMC,SAAS,GAAIC,KAAD,IAAU;AAC5B;AACA;AACA;AACI,sBACI;AAAK,IAAA,SAAS,EAAG,WAAjB;AAAA,4BACA;AAAI,MAAA,SAAS,EAAG,QAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YADA,eAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAFA;AAAA;AAAA;AAAA;AAAA;AAAA,UADJ;AAsBH,CA1BD;;KAAMD,S;AA2BN,qBAAeD,OAAO,CAACC,SAAD,CAAtB","sourcesContent":["import React from 'react';\r\nimport Rainbow from '../hoc/Rainbow'\r\n\r\n\r\nconst ContactUs = (props) =>{ \r\n//  setTimeout(()=> {\r\n//      props.history.push('/home')\r\n//  }, 2000);\r\n    return (\r\n        <div className = \"container\">\r\n        <h4 className = \"center\">ContactUs</h4> \r\n        <p> Unfortunately, the world of programming doesn’t\r\n         really fall into four cleanly separated parts. \r\n         Therefore, the “parts” of this book provide only a \r\n         coarse classification of topics. We consider it a \r\n         useful classification (obviously, or we wouldn’t \r\n         have used it), but reality has a way of escaping \r\n         neat classifications. For example, we need to use\r\n        input operations far sooner than we can give a\r\n        thorough explanation of C++ standard I/O streams\r\n        (input/output streams). Where the set of topics \r\n        needed to present an idea conflicts with the \r\n        overall classification, we explain the minimum \r\n        needed for a good presentation, rather than \r\n        just referring to the complete explanation elsewhere.\r\n         Rigid classifications work much better for manuals \r\n         than for tutorials.\r\n</p>\r\n        </div>\r\n    )\r\n}\r\nexport default Rainbow(ContactUs); "]},"metadata":{},"sourceType":"module"}